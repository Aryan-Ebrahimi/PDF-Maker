import os
import sqlite3
import shutil
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes, 
    ConversationHandler, 
    CallbackQueryHandler
)
from telegram.error import TimedOut
from PIL import Image
import img2pdf
from fpdf import FPDF
import arabic_reshaper
from bidi.algorithm import get_display
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import letter
from PyPDF2 import PdfReader, PdfWriter
from io import BytesIO

# States for ConversationHandler
START, PHOTO_TO_PDF, TEXT_TO_PDF, ASK_FILENAME, ADMIN, ADMIN_GET_PDFS, ADMIN_CLEAR_CONFIRM = range(7)

# Temporary directory for file storage
TEMP_DIR = "temp_files"
if not os.path.exists(TEMP_DIR):
    os.makedirs(TEMP_DIR)

# Admin password
ADMIN_PASSWORD = "walter05"

# Bot watermark text
WATERMARK_TEXT = "Generated by Nova PDF Maker Bot (@nova_pdfbot)"

# Setup SQLite database
def setup_database():
    conn = sqlite3.connect("user_data.db")
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    username TEXT,
                    pdf_count INTEGER DEFAULT 0
                 )''')
    c.execute('''CREATE TABLE IF NOT EXISTS pdfs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    pdf_path TEXT,
                    FOREIGN KEY(user_id) REFERENCES users(user_id)
                 )''')
    conn.commit()
    conn.close()

# Function to add watermark to photo-based PDF
def add_watermark_to_pdf(input_pdf_path, output_pdf_path):
    watermark_buffer = BytesIO()
    c = canvas.Canvas(watermark_buffer, pagesize=letter)
    c.setFont("Helvetica", 10)
    c.setFillColorRGB(0.5, 0.5, 0.5, alpha=0.5)
    c.drawString(50, 50, WATERMARK_TEXT)
    c.save()

    watermark_buffer.seek(0)
    watermark_pdf = PdfReader(watermark_buffer)
    input_pdf = PdfReader(input_pdf_path)
    output = PdfWriter()

    for page in input_pdf.pages:
        page.merge_page(watermark_pdf.pages[0])
        output.add_page(page)

    with open(output_pdf_path, "wb") as f:
        output.write(f)

# Function to clear all data
def clear_all_data():
    # Clear database
    conn = sqlite3.connect("user_data.db")
    c = conn.cursor()
    c.execute("DELETE FROM users")
    c.execute("DELETE FROM pdfs")
    conn.commit()
    conn.close()

    # Clear temp_files directory
    if os.path.exists(TEMP_DIR):
        shutil.rmtree(TEMP_DIR)
        os.makedirs(TEMP_DIR)

# Start function
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [InlineKeyboardButton("üì∏ Convert Photos to PDF", callback_data="photo_to_pdf")],
        [InlineKeyboardButton("üìù Convert Text to PDF", callback_data="text_to_pdf")],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "‚ú® Welcome to the Nova File Converter Bot! ‚ú®\n"
        "Choose an option:",
        reply_markup=reply_markup
    )
    return START

# Button handler
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    if query.data == "photo_to_pdf":
        await query.edit_message_text(
            "üì∏ Send the photos you want to convert to PDF.\n"
            "When done, type 'done' ‚úÖ"
        )
        return PHOTO_TO_PDF
    elif query.data == "text_to_pdf":
        await query.edit_message_text(
            "üìù Send the text you want to convert to PDF:"
        )
        return TEXT_TO_PDF
    return START

# Handler for checking admin password in START state
async def check_admin_password(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    message_text = update.message.text.strip()
    
    if message_text == ADMIN_PASSWORD:
        context.user_data["failed_attempts"] = 0  # Reset attempts
        keyboard = [
            [InlineKeyboardButton("üë• Show User Stats", callback_data="show_users")],
            [InlineKeyboardButton("üìÇ Get User PDFs", callback_data="get_pdfs")],
            [InlineKeyboardButton("üóëÔ∏è Clear All Data", callback_data="clear_data")],
        ]
        await update.message.reply_text(
            "üîí Welcome to the Admin Panel!\nChoose an option:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ADMIN
    else:
        context.user_data["failed_attempts"] = context.user_data.get("failed_attempts", 0) + 1
        if context.user_data["failed_attempts"] >= 3:
            await update.message.reply_text("‚ùå Too many failed attempts. Access blocked!")
            context.user_data["failed_attempts"] = 0
            return ConversationHandler.END
        await update.message.reply_text(
            f"‚ùå Invalid input. {3 - context.user_data['failed_attempts']} attempts left."
        )
        return START

# Photo handler
async def photo_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not context.user_data.get("photos"):
        context.user_data["photos"] = []

    if update.message.text and update.message.text.lower() == "done":
        if not context.user_data["photos"]:
            await update.message.reply_text("‚ö†Ô∏è No photos sent! Try again.")
            return PHOTO_TO_PDF
        
        context.user_data["conversion_type"] = "photo"
        await update.message.reply_text("üìÑ What would you like to name your PDF file?")
        return ASK_FILENAME

    if not update.message.photo:
        await update.message.reply_text("üì∏ Please send only photos or type 'done'.")
        return PHOTO_TO_PDF
    
    photo_file = await update.message.photo[-1].get_file()
    photo_path = os.path.join(TEMP_DIR, f"photo_{len(context.user_data['photos'])}_{update.message.from_user.id}.jpg")
    await photo_file.download_to_drive(photo_path)
    context.user_data["photos"].append(photo_path)
    await update.message.reply_text(f"‚úÖ Photo {len(context.user_data['photos'])} received.\nNext photo or 'done'?")
    return PHOTO_TO_PDF

# Text handler
async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    text = update.message.text
    context.user_data["text"] = text
    context.user_data["conversion_type"] = "text"
    await update.message.reply_text("üìÑ What would you like to name your PDF file?")
    return ASK_FILENAME

# Handler for asking filename and creating PDF
async def ask_filename_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    filename = update.message.text.strip()
    if not filename:
        await update.message.reply_text("‚ö†Ô∏è Please enter a valid filename!")
        return ASK_FILENAME
    
    if not filename.lower().endswith(".pdf"):
        filename += ".pdf"

    user_id = update.message.from_user.id
    username = update.message.from_user.username or "NoUsername"
    conversion_type = context.user_data.get("conversion_type")
    
    conn = sqlite3.connect("user_data.db")
    c = conn.cursor()
    c.execute("INSERT OR IGNORE INTO users (user_id, username, pdf_count) VALUES (?, ?, 0)", (user_id, username))
    conn.commit()

    if conversion_type == "photo":
        await update.message.reply_text(f"‚è≥ Converting photos to PDF as '{filename}'...")
        temp_pdf_path = os.path.join(TEMP_DIR, f"temp_{user_id}_{filename}")
        pdf_path = os.path.join(TEMP_DIR, f"output_{user_id}_{filename}")
        try:
            with open(temp_pdf_path, "wb") as f:
                f.write(img2pdf.convert(context.user_data["photos"]))
            
            add_watermark_to_pdf(temp_pdf_path, pdf_path)
            
            try:
                with open(pdf_path, "rb") as f:
                    await update.message.reply_document(f, filename=filename, caption="üìÑ PDF file is ready!")
                c.execute("INSERT INTO pdfs (user_id, pdf_path) VALUES (?, ?)", (user_id, pdf_path))
                c.execute("UPDATE users SET pdf_count = pdf_count + 1 WHERE user_id = ?", (user_id,))
                conn.commit()
            except TimedOut:
                await update.message.reply_text("‚ö†Ô∏è File upload failed. Please try again.")
                return PHOTO_TO_PDF
            
            for photo_path in context.user_data["photos"]:
                os.remove(photo_path)
            os.remove(temp_pdf_path)
            context.user_data["photos"] = []
        
        except Exception as e:
            await update.message.reply_text(f"‚ö†Ô∏è Error: {str(e)}")
            return PHOTO_TO_PDF

    elif conversion_type == "text":
        await update.message.reply_text(f"‚è≥ Converting text to PDF as '{filename}'...")
        pdf = FPDF()
        pdf.add_page()
        
        pdf.add_font("Vazir", "", "Vazirmatn-Regular.ttf", uni=True)
        pdf.set_font("Vazir", size=12)
        
        text = context.user_data["text"]
        reshaped_text = arabic_reshaper.reshape(text)
        bidi_text = get_display(reshaped_text)
        pdf.set_right_margin(10)
        pdf.set_left_margin(10)
        pdf.set_xy(10, 10)
        pdf.multi_cell(0, 10, bidi_text, align='R')
        
        pdf.set_xy(10, pdf.get_y() + 10)
        pdf.set_font("Vazir", size=8)
        watermark_reshaped = arabic_reshaper.reshape(WATERMARK_TEXT)
        watermark_bidi = get_display(watermark_reshaped)
        pdf.set_text_color(128, 128, 128)
        pdf.multi_cell(0, 10, watermark_bidi, align='C')
        
        pdf_path = os.path.join(TEMP_DIR, f"text_{user_id}_{filename}")
        try:
            pdf.output(pdf_path)
            with open(pdf_path, "rb") as f:
                await update.message.reply_document(f, filename=filename, caption="üìÑ PDF file is ready!")
            c.execute("INSERT INTO pdfs (user_id, pdf_path) VALUES (?, ?)", (user_id, pdf_path))
            c.execute("UPDATE users SET pdf_count = pdf_count + 1 WHERE user_id = ?", (user_id,))
            conn.commit()
        except TimedOut:
            await update.message.reply_text("‚ö†Ô∏è File upload failed. Please try again.")
            return TEXT_TO_PDF
        except Exception as e:
            await update.message.reply_text(f"‚ö†Ô∏è Error generating PDF: {str(e)}")
            return TEXT_TO_PDF

    conn.close()

    context.user_data.pop("conversion_type", None)
    context.user_data.pop("text", None)

    keyboard = [
        [InlineKeyboardButton("üì∏ Convert New Photos", callback_data="photo_to_pdf")],
        [InlineKeyboardButton("üìù Convert New Text", callback_data="text_to_pdf")],
    ]
    await update.message.reply_text("‚úÖ PDF created successfully! What‚Äôs next?", reply_markup=InlineKeyboardMarkup(keyboard))
    return START

# Admin button handler
async def admin_button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    query = update.callback_query
    await query.answer()

    return_keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("üîô Back to Admin Panel", callback_data="back_to_admin")]])

    if query.data == "show_users":
        conn = sqlite3.connect("user_data.db")
        c = conn.cursor()
        c.execute("SELECT user_id, username, pdf_count FROM users")
        users = c.fetchall()
        conn.close()

        if not users:
            await query.edit_message_text("‚ö†Ô∏è No users found!")
        else:
            response = "üë• User Stats:\n\n"
            for user_id, username, pdf_count in users:
                response += f"Username: @{username}\nID: {user_id}\nPDFs Created: {pdf_count}\n\n"
            await query.edit_message_text(response)
        await query.message.reply_text("üîß What‚Äôs next?", reply_markup=return_keyboard)
        return ADMIN

    elif query.data == "get_pdfs":
        await query.edit_message_text("üìÇ Please send the User ID to get their PDFs:")
        return ADMIN_GET_PDFS

    elif query.data == "clear_data":
        keyboard = [
            [InlineKeyboardButton("‚úÖ Confirm", callback_data="confirm_clear")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="back_to_admin")],
        ]
        await query.edit_message_text(
            "‚ö†Ô∏è Are you sure you want to clear all user data and PDFs? This action cannot be undone!",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ADMIN_CLEAR_CONFIRM

    elif query.data == "confirm_clear":
        try:
            clear_all_data()
            await query.edit_message_text("üóëÔ∏è All user data and PDFs have been cleared successfully!")
        except Exception as e:
            await query.edit_message_text(f"‚ö†Ô∏è Error clearing data: {str(e)}")
        await query.message.reply_text("üîß What‚Äôs next?", reply_markup=return_keyboard)
        return ADMIN

    elif query.data == "back_to_admin":
        keyboard = [
            [InlineKeyboardButton("üë• Show User Stats", callback_data="show_users")],
            [InlineKeyboardButton("üìÇ Get User PDFs", callback_data="get_pdfs")],
            [InlineKeyboardButton("üóëÔ∏è Clear All Data", callback_data="clear_data")],
        ]
        await query.edit_message_text(
            "üîí Welcome back to the Admin Panel!\nChoose an option:",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
        return ADMIN

    return ADMIN

# Handler for getting PDFs by user ID
async def admin_get_pdfs_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.message.text.strip()
    try:
        user_id = int(user_id)
    except ValueError:
        await update.message.reply_text("‚ö†Ô∏è Please enter a valid User ID (numeric)!")
        return ADMIN_GET_PDFS

    conn = sqlite3.connect("user_data.db")
    c = conn.cursor()
    c.execute("SELECT pdf_path FROM pdfs WHERE user_id = ?", (user_id,))
    pdfs = c.fetchall()
    conn.close()

    return_keyboard = InlineKeyboardMarkup([[InlineKeyboardButton("üîô Back to Admin Panel", callback_data="back_to_admin")]])

    if not pdfs:
        await update.message.reply_text(f"‚ö†Ô∏è No PDFs found for User ID {user_id}!", reply_markup=return_keyboard)
    else:
        await update.message.reply_text(f"üìÇ Sending {len(pdfs)} PDFs for User ID {user_id}...")
        for pdf_path, in pdfs:
            if os.path.exists(pdf_path):
                with open(pdf_path, "rb") as f:
                    await update.message.reply_document(f, caption=f"PDF from User ID {user_id}")
            else:
                await update.message.reply_text(f"‚ö†Ô∏è File {pdf_path} not found on server!")
        await update.message.reply_text("üîß What‚Äôs next?", reply_markup=return_keyboard)

    return ADMIN

# Cancel function
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("‚ùå Operation canceled. Come back anytime!")
    return ConversationHandler.END

def main() -> None:
    setup_database()
    application = Application.builder().token("7717198810:AAEhp5oSXe1ttlcRPctA3vjpsz9HpH6NjxU").build()

    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("start", start),
        ],
        states={
            START: [
                CallbackQueryHandler(button),
                MessageHandler(filters.TEXT & ~filters.COMMAND, check_admin_password),
            ],
            PHOTO_TO_PDF: [MessageHandler(filters.PHOTO | filters.TEXT, photo_handler)],
            TEXT_TO_PDF: [MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler)],
            ASK_FILENAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, ask_filename_handler)],
            ADMIN: [CallbackQueryHandler(admin_button)],
            ADMIN_GET_PDFS: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_get_pdfs_handler)],
            ADMIN_CLEAR_CONFIRM: [CallbackQueryHandler(admin_button)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    application.add_handler(conv_handler)
    application.run_polling()

if __name__ == "__main__":
    main()